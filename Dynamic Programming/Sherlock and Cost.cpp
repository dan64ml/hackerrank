/*
 * Две идеи: 1. Есть смысл рассматривать только крайние значения: 1 или B[i]
 * 2. Они не обязательно должны чередоваться. Пример: B = {10, 4, 4, 10}.
 * оптимально выбрать 10, 1, 1, 10.
 * Это дает простую динамику: s[0][i] - сумма оканчивающаяся на 1, s[1][i] - на B[i]
 *
 * s[0][i + 1] = max(s[1][i] + abs(B[i] - 1), s[0][i])
 * s[1][i + 1] = max(s[0][i] + abs(B[i + 1] - 1), s[1][i])
 *
*/
int cost(vector<int> B) {
    int s[2];
    s[0] = abs(B[0] - 1);
    s[1] = abs(B[1] - 1);

    for (int n = 2; n < B.size(); ++n) {
        int t1 = max(s[1] + abs(B[n - 1] - 1), s[0]);
        int t2 = max(s[0] + abs(B[n] - 1), s[1]);

        s[0] = t1;
        s[1] = t2;
    }

    return max(s[0], s[1]);
}
