/*
 * Пусть n - заданная сумма, а с[] - набор монет.
 * S(n, c) - количество комбинаций, дающих заданную сумму.
 *
 * Динамика вида S(n) = | 1, n < c[i]
 *                      | SUM(S(n - c[i])), для c[i] <= n
 *
 * дает количество комбинаций с учетом возможных перестановок, что
 * не соответствунт условию задачи. Гиганское количество перестановок
 * делает фильтрацию дублей нерациональной.
 *
 * Более хитрая динамика:
 * S(n, i) - количество комбинаций, дающих сумму n с использованием
 * первых i монет из списка. Тогда:
 *
 * S(n, i) = | 1, n = 0
 *           | SUM(S(n - k * c[i - 1], i - 1)), где k = 0, 1,... пока (n - k*c[i-1]) >= 0
 */


long getWays(int n, vector<long> c) {
    vector<vector<long>> cash(n + 1, vector<long>(c.size() + 1, 0));
    for (auto& e : cash[0]) {
        e = 1;
    }

    for (int i = 1; i <= c.size(); ++i) {
        for (long s = 1; s <= n; ++s) {
            long subsum = s;
            while (subsum >= 0) {
                cash[s][i] += cash[subsum][i - 1];
                subsum -= c[i - 1];
            }
        }
    }

    return cash.back().back();
}
