/*
 * Идея: пусть у нас нет ограничения на правую границу. Задача становится тривиальной.
 * Если граница установлена, из предыдущего решения нужно взять только те массивы, которые
 * заканчиваются на х.
 * Пусть a[i] - количество массивов длины i, заканчивающихся на х,
 * а b[i] - не заканчивающихся на х. Тогда:
 * a[i] = b[i - 1], т.к. таких вариантов будет ровно столько, сколько не оканчивалось на х
 * b[i] = a[i - 1] * (k - 1) + b[i - 1] * (k - 2) первое слагаемое очевидно, второе возникает
 * из-за требования что значение b[i] не содержит массивы заканчивающиеся на х.
 * 
 * Начальные условия:
 * если (х == к),то a[0] = 1 b[0] = 0 
 * иначе a[0] = 0 b[0] = 1
 *
*/

// Complete the countArray function below.
long countArray(int n, int k, int x) {
    // Return the number of ways to fill in the array.
    const long MOD = 1000000007;

    vector<long> end_x(n);
    vector<long> other(n);

    end_x[0] = (x == 1) ? 1 : 0;
    other[0] = (x == 1) ? 0 : 1;

    for (int i = 1; i < n; ++i) {
        end_x[i] = other[i - 1];
        other[i] = (end_x[i - 1] * (k - 1) + other[i - 1] * (k - 2)) % MOD;
    }

    return end_x.back();
}
